# 青羽平台 - 组件开发规范

> **版本**: v1.0.0  
> **最后更新**: 2025-10-29  
> **适用范围**: 所有Vue组件开发

---

## 📋 目录

1. [组件分层](#组件分层)
2. [命名规范](#命名规范)
3. [Props设计](#props设计)
4. [Events设计](#events设计)
5. [Slots设计](#slots设计)
6. [组件文档](#组件文档)
7. [性能优化](#性能优化)
8. [最佳实践](#最佳实践)

---

## 组件分层

### 三层架构

```
┌─────────────────────────────────────┐
│         页面组件 (Pages)             │
│       业务逻辑组合和页面布局          │
├─────────────────────────────────────┤
│        业务组件 (Business)            │
│       包含特定业务逻辑的组件          │
├─────────────────────────────────────┤
│        基础组件 (Base/Common)         │
│       纯UI组件，无业务逻辑            │
└─────────────────────────────────────┘
```

### 基础组件 (Base Components)

**位置**: `src/shared/components/base/`

**特征**:
- 纯UI组件，不包含业务逻辑
- 高度可复用
- 通过props接收数据，通过events传递事件
- 可独立使用和测试

**示例**:

```vue
<!-- BaseButton.vue -->
<template>
  <button 
    :class="buttonClass"
    :disabled="disabled"
    :type="nativeType"
    @click="handleClick"
  >
    <slot />
  </button>
</template>

<script setup lang="ts">
import { computed } from 'vue'

interface Props {
  type?: 'default' | 'primary' | 'success' | 'warning' | 'danger'
  size?: 'small' | 'medium' | 'large'
  disabled?: boolean
  nativeType?: 'button' | 'submit' | 'reset'
}

const props = withDefaults(defineProps<Props>(), {
  type: 'default',
  size: 'medium',
  disabled: false,
  nativeType: 'button',
})

const emit = defineEmits<{
  click: [event: MouseEvent]
}>()

const buttonClass = computed(() => {
  return [
    'base-button',
    `base-button--${props.type}`,
    `base-button--${props.size}`,
    {
      'base-button--disabled': props.disabled,
    },
  ]
})

const handleClick = (event: MouseEvent) => {
  if (!props.disabled) {
    emit('click', event)
  }
}
</script>

<style scoped>
.base-button {
  padding: var(--spacing-sm) var(--spacing-md);
  border-radius: var(--border-radius-base);
  border: 1px solid var(--border-base);
  cursor: pointer;
  transition: var(--transition-base);
}

.base-button--primary {
  background-color: var(--color-primary);
  color: white;
  border-color: var(--color-primary);
}

.base-button--small {
  padding: var(--spacing-xs) var(--spacing-sm);
  font-size: var(--font-size-small);
}

.base-button--disabled {
  opacity: 0.6;
  cursor: not-allowed;
}
</style>
```

### 通用组件 (Common Components)

**位置**: `src/shared/components/common/`

**特征**:
- 包含通用的交互逻辑
- 跨模块使用
- 可配置性强

**示例**:

```vue
<!-- Pagination.vue -->
<template>
  <div class="pagination">
    <button 
      class="pagination__btn"
      :disabled="currentPage === 1"
      @click="handlePrev"
    >
      上一页
    </button>
    
    <div class="pagination__pages">
      <span 
        v-for="page in displayPages" 
        :key="page"
        :class="['pagination__page', { 'is-active': page === currentPage }]"
        @click="handlePageChange(page)"
      >
        {{ page }}
      </span>
    </div>
    
    <button 
      class="pagination__btn"
      :disabled="currentPage === totalPages"
      @click="handleNext"
    >
      下一页
    </button>
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue'

interface Props {
  currentPage: number
  totalPages: number
  maxDisplayPages?: number
}

const props = withDefaults(defineProps<Props>(), {
  maxDisplayPages: 7,
})

const emit = defineEmits<{
  'update:currentPage': [page: number]
  'change': [page: number]
}>()

const displayPages = computed(() => {
  // 计算要显示的页码
  const pages: number[] = []
  const half = Math.floor(props.maxDisplayPages / 2)
  let start = Math.max(1, props.currentPage - half)
  let end = Math.min(props.totalPages, start + props.maxDisplayPages - 1)
  
  if (end - start + 1 < props.maxDisplayPages) {
    start = Math.max(1, end - props.maxDisplayPages + 1)
  }
  
  for (let i = start; i <= end; i++) {
    pages.push(i)
  }
  
  return pages
})

const handlePageChange = (page: number) => {
  if (page !== props.currentPage) {
    emit('update:currentPage', page)
    emit('change', page)
  }
}

const handlePrev = () => {
  if (props.currentPage > 1) {
    handlePageChange(props.currentPage - 1)
  }
}

const handleNext = () => {
  if (props.currentPage < props.totalPages) {
    handlePageChange(props.currentPage + 1)
  }
}
</script>
```

### 业务组件 (Business Components)

**位置**: `src/modules/[module]/components/`

**特征**:
- 包含特定业务逻辑
- 与业务数据和API交互
- 复用性相对较低
- 组合使用基础组件

**示例**:

```vue
<!-- BookCard.vue -->
<template>
  <div class="book-card" @click="handleClick">
    <div class="book-card__cover">
      <img :src="book.cover" :alt="book.title" loading="lazy" />
      <div v-if="book.isVip" class="book-card__badge">VIP</div>
    </div>
    
    <div class="book-card__content">
      <h3 class="book-card__title">{{ book.title }}</h3>
      <p class="book-card__author">{{ book.author }}</p>
      
      <div class="book-card__stats">
        <span class="book-card__stat">
          <el-icon><View /></el-icon>
          {{ formatNumber(book.views) }}
        </span>
        <span class="book-card__stat">
          <el-icon><Star /></el-icon>
          {{ book.rating }}
        </span>
      </div>
      
      <div class="book-card__tags">
        <el-tag v-for="tag in book.tags" :key="tag" size="small">
          {{ tag }}
        </el-tag>
      </div>
    </div>
    
    <div class="book-card__actions">
      <el-button 
        size="small" 
        type="primary"
        @click.stop="handleRead"
      >
        开始阅读
      </el-button>
      <el-button 
        size="small"
        :icon="isFavorite ? StarFilled : Star"
        @click.stop="handleFavorite"
      >
        {{ isFavorite ? '已收藏' : '收藏' }}
      </el-button>
    </div>
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue'
import { Star, StarFilled, View } from '@element-plus/icons-vue'
import type { Book } from '@/types/bookstore'

interface Props {
  book: Book
  favoriteIds?: string[]
}

const props = defineProps<Props>()

const emit = defineEmits<{
  click: [book: Book]
  read: [book: Book]
  favorite: [book: Book]
}>()

const isFavorite = computed(() => {
  return props.favoriteIds?.includes(props.book.id) || false
})

const formatNumber = (num: number): string => {
  if (num >= 10000) {
    return `${(num / 10000).toFixed(1)}万`
  }
  return num.toString()
}

const handleClick = () => {
  emit('click', props.book)
}

const handleRead = () => {
  emit('read', props.book)
}

const handleFavorite = () => {
  emit('favorite', props.book)
}
</script>
```

### 页面组件 (Page Components)

**位置**: `src/modules/[module]/views/` 或 `src/pages/`

**特征**:
- 组合多个组件形成完整页面
- 处理页面级别的状态管理
- 与路由系统集成

**示例**:

```vue
<!-- BookListView.vue -->
<template>
  <div class="book-list-view">
    <PageHeader title="书籍列表">
      <template #actions>
        <SearchInput v-model="searchQuery" @search="handleSearch" />
      </template>
    </PageHeader>
    
    <FilterPanel
      v-model:filters="filters"
      :categories="categories"
      @change="handleFilterChange"
    />
    
    <LoadingSpinner v-if="loading" />
    
    <EmptyState v-else-if="!books.length" message="暂无书籍" />
    
    <div v-else class="book-list-view__grid">
      <BookCard
        v-for="book in books"
        :key="book.id"
        :book="book"
        :favorite-ids="favoriteIds"
        @click="handleBookClick"
        @read="handleRead"
        @favorite="handleFavorite"
      />
    </div>
    
    <Pagination
      v-model:current-page="currentPage"
      :total-pages="totalPages"
      @change="handlePageChange"
    />
  </div>
</template>

<script setup lang="ts">
import { ref, reactive, onMounted, watch } from 'vue'
import { useRouter } from 'vue-router'
import { useBookstoreStore } from '@bookstore/stores/bookstore.store'
import type { Book, BookFilters } from '@/types/bookstore'

const router = useRouter()
const bookstoreStore = useBookstoreStore()

const loading = ref(false)
const searchQuery = ref('')
const currentPage = ref(1)
const totalPages = ref(1)
const books = ref<Book[]>([])
const favoriteIds = ref<string[]>([])
const categories = ref([])

const filters = reactive<BookFilters>({
  category: '',
  status: '',
  tags: [],
})

const fetchBooks = async () => {
  loading.value = true
  try {
    const result = await bookstoreStore.fetchBooks({
      page: currentPage.value,
      query: searchQuery.value,
      ...filters,
    })
    books.value = result.books
    totalPages.value = result.totalPages
  } finally {
    loading.value = false
  }
}

const handleSearch = () => {
  currentPage.value = 1
  fetchBooks()
}

const handleFilterChange = () => {
  currentPage.value = 1
  fetchBooks()
}

const handlePageChange = () => {
  fetchBooks()
}

const handleBookClick = (book: Book) => {
  router.push(`/books/${book.id}`)
}

const handleRead = (book: Book) => {
  router.push(`/reader/${book.id}`)
}

const handleFavorite = async (book: Book) => {
  await bookstoreStore.toggleFavorite(book.id)
  // 更新收藏列表
}

onMounted(() => {
  fetchBooks()
})
</script>
```

---

## 命名规范

### 文件命名

**组件文件**: 使用 **PascalCase**

```
✅ 正确：
BookCard.vue
UserProfile.vue
SearchBar.vue
BookDetailView.vue

❌ 错误：
bookCard.vue
book-card.vue
book_card.vue
Card.vue  // 单词组件名
```

**其他文件**: 使用 **kebab-case**

```
✅ 正确：
use-book-list.ts
book-api.ts
format-utils.ts

❌ 错误：
useBookList.ts
bookAPI.ts
formatUtils.ts
```

### 组件命名

```typescript
// ✅ 正确：多词组件名
export default {
  name: 'BookCard'
}

export default {
  name: 'UserProfile'
}

// ❌ 错误：单词组件名
export default {
  name: 'Card'
}
```

### Props 命名

使用 **camelCase** (JavaScript) 和 **kebab-case** (模板)：

```vue
<script setup lang="ts">
// JavaScript 中使用 camelCase
defineProps<{
  bookId: string
  isActive: boolean
  maxCount: number
}>()
</script>

<template>
  <!-- 模板中使用 kebab-case -->
  <BookCard
    :book-id="id"
    :is-active="active"
    :max-count="10"
  />
</template>
```

### Events 命名

使用 **kebab-case**：

```typescript
// ✅ 正确
emit('book-click', book)
emit('item-selected', item)
emit('data-loaded')

// ❌ 错误
emit('bookClick', book)
emit('itemSelected', item)
emit('dataLoaded')
```

---

## Props设计

### 基本原则

1. **明确的类型定义**
2. **合理的默认值**
3. **必要的验证**
4. **清晰的文档**

### TypeScript Props

```typescript
interface Props {
  // 必填项
  id: string
  title: string
  
  // 可选项带默认值
  size?: 'small' | 'medium' | 'large'
  disabled?: boolean
  
  // 对象/数组需要工厂函数
  items?: string[]
  config?: Record<string, any>
  
  // 自定义类型
  book?: Book
  user?: User
}

const props = withDefaults(defineProps<Props>(), {
  size: 'medium',
  disabled: false,
  items: () => [],
  config: () => ({}),
})
```

### Props 验证

```typescript
// 自定义验证
interface Props {
  status: 'draft' | 'published' | 'archived'
  count: number
  email: string
}

const props = defineProps<Props>()

// 运行时验证
const validateProps = () => {
  if (props.count < 0) {
    console.warn('count must be positive')
  }
  
  if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(props.email)) {
    console.warn('invalid email format')
  }
}
```

### 避免 Props 修改

```typescript
// ❌ 错误：直接修改 props
const props = defineProps<{ value: string }>()
props.value = 'new value'  // 错误！

// ✅ 正确：使用 computed 或 emit
const props = defineProps<{ modelValue: string }>()
const emit = defineEmits<{
  'update:modelValue': [value: string]
}>()

const localValue = computed({
  get: () => props.modelValue,
  set: (val) => emit('update:modelValue', val)
})
```

---

## Events设计

### 命名规范

使用 **kebab-case** 和动词开头：

```typescript
// ✅ 推荐
emit('item-click', item)
emit('data-change', data)
emit('file-upload', file)
emit('user-login')

// ❌ 不推荐
emit('itemClick')
emit('change')  // 太泛化
emit('click')   // 太泛化
```

### TypeScript Events

```typescript
// 定义事件类型
interface Emits {
  'item-click': [item: Item]
  'item-select': [item: Item, selected: boolean]
  'data-change': [data: Data]
  'update:modelValue': [value: string]
}

const emit = defineEmits<Emits>()

// 触发事件
emit('item-click', item)
emit('item-select', item, true)
emit('data-change', data)
emit('update:modelValue', 'new value')
```

### v-model 支持

```vue
<script setup lang="ts">
// 单个 v-model
const props = defineProps<{
  modelValue: string
}>()

const emit = defineEmits<{
  'update:modelValue': [value: string]
}>()

// 多个 v-model
const props = defineProps<{
  modelValue: string
  visible: boolean
}>()

const emit = defineEmits<{
  'update:modelValue': [value: string]
  'update:visible': [visible: boolean]
}>()
</script>

<template>
  <!-- 使用 -->
  <MyComponent v-model="value" v-model:visible="isVisible" />
</template>
```

---

## Slots设计

### 默认插槽

```vue
<template>
  <div class="card">
    <slot>
      <!-- 默认内容 -->
      <p>暂无内容</p>
    </slot>
  </div>
</template>
```

### 具名插槽

```vue
<template>
  <div class="card">
    <div class="card__header">
      <slot name="header">
        <h3>默认标题</h3>
      </slot>
    </div>
    
    <div class="card__body">
      <slot />
    </div>
    
    <div class="card__footer">
      <slot name="footer" />
    </div>
  </div>
</template>

<!-- 使用 -->
<Card>
  <template #header>
    <h2>自定义标题</h2>
  </template>
  
  <p>卡片内容</p>
  
  <template #footer>
    <button>确定</button>
  </template>
</Card>
```

### 作用域插槽

```vue
<template>
  <ul class="list">
    <li v-for="(item, index) in items" :key="item.id">
      <slot name="item" :item="item" :index="index">
        <!-- 默认渲染 -->
        {{ item.name }}
      </slot>
    </li>
  </ul>
</template>

<!-- 使用 -->
<List :items="books">
  <template #item="{ item, index }">
    <div>
      <span>{{ index + 1 }}.</span>
      <strong>{{ item.title }}</strong>
      <span>by {{ item.author }}</span>
    </div>
  </template>
</List>
```

---

## 组件文档

### 文档模板

每个组件应包含以下文档：

```vue
<!--
# BookCard 组件

书籍卡片组件，用于展示书籍信息。

## Props

| 名称        | 类型                           | 默认值   | 必填 | 说明             |
| ----------- | ------------------------------ | -------- | ---- | ---------------- |
| book        | Book                           | -        | 是   | 书籍对象         |
| size        | 'small' \| 'medium' \| 'large' | 'medium' | 否   | 卡片尺寸         |
| showActions | boolean                        | true     | 否   | 是否显示操作按钮 |

## Events

| 名称     | 参数         | 说明               |
| -------- | ------------ | ------------------ |
| click    | (book: Book) | 点击卡片时触发     |
| read     | (book: Book) | 点击阅读按钮时触发 |
| favorite | (book: Book) | 点击收藏按钮时触发 |

## Slots

| 名称    | 作用域   | 说明           |
| ------- | -------- | -------------- |
| default | -        | 卡片默认内容   |
| actions | { book } | 自定义操作按钮 |

## 使用示例

```vue
<BookCard
  :book="book"
  size="large"
  @click="handleClick"
  @read="handleRead"
  @favorite="handleFavorite"
>
  <template #actions="{ book }">
    <el-button>自定义操作</el-button>
  </template>
</BookCard>
```
-->
```

---

## 性能优化

### 1. 使用 v-memo

```vue
<template>
  <div v-for="item in list" :key="item.id" v-memo="[item.id, item.status]">
    <!-- 只在 id 或 status 变化时重新渲染 -->
    <BookCard :book="item" />
  </div>
</template>
```

### 2. 组件懒加载

```typescript
// 路由懒加载
const routes = [
  {
    path: '/books',
    component: () => import('@/views/BooksView.vue')
  }
]

// 组件懒加载
const AsyncComponent = defineAsyncComponent(() =>
  import('@/components/HeavyComponent.vue')
)
```

### 3. 使用 shallowRef/shallowReactive

```typescript
// 对于大型不可变数据
const bigData = shallowRef({
  // 大量数据
})

// 只在顶层属性变化时触发更新
watch(bigData, (newVal) => {
  // 处理
}, { deep: false })
```

### 4. 虚拟滚动

对于长列表，使用虚拟滚动：

```typescript
import { useVirtualList } from '@/composables/useVirtualList'

const { list, containerProps, wrapperProps } = useVirtualList(
  items,
  { itemHeight: 50 }
)
```

---

## 最佳实践

### ✅ 推荐做法

1. **单一职责原则**：每个组件只做一件事
2. **Props向下，Events向上**：遵循单向数据流
3. **使用TypeScript**：提供类型安全
4. **组件文档齐全**：方便其他开发者使用
5. **性能优化**：合理使用优化手段
6. **测试覆盖**：编写单元测试

### ❌ 避免做法

1. **直接修改Props**
2. **过度使用全局状态**
3. **组件职责不清**
4. **缺少类型定义**
5. **过早优化**

---

**维护者**: 前端团队  
**最后更新**: 2025-10-29  
**版本**: v1.0.0

