# 青羽后端 API 前端集成指南

> **版本**: v1.3 ⭐️已更新  
> **最后更新**: 2025-10-25  
> **适用对象**: 前端开发者  
> **主要更新**: 统一响应格式、评论点赞功能、错误追踪

## 📋 目录

- [快速开始](#快速开始)
- [认证流程](#认证流程)
- [统一请求封装](#统一请求封装)
- [核心功能集成](#核心功能集成)
- [最佳实践](#最佳实践)
- [常见问题](#常见问题)

---

## 快速开始

### 1. 环境配置

#### API 基础 URL

```javascript
// 开发环境
const API_BASE_URL = 'http://localhost:8080/api/v1';

// 生产环境
const API_BASE_URL = 'https://api.qingyu.com/api/v1';
```

#### 推荐配置方式

**使用环境变量（推荐）**

```javascript
// .env.development
VITE_API_BASE_URL=http://localhost:8080/api/v1

// .env.production
VITE_API_BASE_URL=https://api.qingyu.com/api/v1
```

```javascript
// config/api.js
export const API_BASE_URL = import.meta.env.VITE_API_BASE_URL;
```

### 2. 安装依赖

```bash
# 使用 axios 作为HTTP客户端
npm install axios

# 或使用 yarn
yarn add axios
```

---

## 认证流程

### Token 获取与存储

青羽后端使用 **JWT Token** 进行身份认证。

#### 登录获取 Token

```javascript
// api/auth.js
import axios from 'axios';
import { API_BASE_URL } from './config';

export async function login(username, password) {
  const response = await axios.post(`${API_BASE_URL}/login`, {
    username,
    password
  });
  
  const { token, userID, username: userName } = response.data.data;
  
  // 存储 Token
  localStorage.setItem('token', token);
  localStorage.setItem('userId', userID);
  localStorage.setItem('username', userName);
  
  return response.data;
}
```

#### Token 存储方案对比

| 存储方式 | 优点 | 缺点 | 推荐场景 |
|---------|------|------|---------|
| localStorage | 简单易用，永久存储 | 容易受XSS攻击 | 一般应用 |
| sessionStorage | 关闭浏览器自动清除 | 多标签页不共享 | 高安全要求 |
| Cookie (httpOnly) | 防XSS，自动发送 | 配置复杂，受CSRF影响 | 企业级应用 |
| 内存存储 | 最安全 | 刷新页面丢失 | 极高安全要求 |

**推荐方案**：localStorage + Token过期自动刷新

### Token 使用

#### 在请求头中携带 Token

```javascript
axios.get(`${API_BASE_URL}/users/profile`, {
  headers: {
    'Authorization': `Bearer ${localStorage.getItem('token')}`
  }
});
```

### Token 刷新

```javascript
export async function refreshToken() {
  const oldToken = localStorage.getItem('token');
  
  try {
    const response = await axios.post(
      `${API_BASE_URL}/shared/auth/refresh`,
      {},
      {
        headers: {
          'Authorization': `Bearer ${oldToken}`
        }
      }
    );
    
    const { token: newToken } = response.data.data;
    localStorage.setItem('token', newToken);
    
    return newToken;
  } catch (error) {
    // Token 刷新失败，需要重新登录
    logout();
    window.location.href = '/login';
    throw error;
  }
}
```

### 退出登录

```javascript
export async function logout() {
  const token = localStorage.getItem('token');
  
  try {
    await axios.post(
      `${API_BASE_URL}/shared/auth/logout`,
      {},
      {
        headers: {
          'Authorization': `Bearer ${token}`
        }
      }
    );
  } catch (error) {
    console.error('登出失败:', error);
  } finally {
    // 清除本地存储
    localStorage.removeItem('token');
    localStorage.removeItem('userId');
    localStorage.removeItem('username');
  }
}
```

---

## 统一请求封装

### Axios 实例配置

创建统一的 HTTP 客户端实例：

```javascript
// utils/request.js
import axios from 'axios';
import { API_BASE_URL } from '../config/api';
import { refreshToken } from '../api/auth';

// 创建 axios 实例
const request = axios.create({
  baseURL: API_BASE_URL,
  timeout: 30000,
  headers: {
    'Content-Type': 'application/json'
  }
});

// 请求拦截器
request.interceptors.request.use(
  config => {
    // 添加 Token
    const token = localStorage.getItem('token');
    if (token) {
      config.headers['Authorization'] = `Bearer ${token}`;
    }
    
    // 添加请求时间戳（防止缓存）
    if (config.method === 'get') {
      config.params = {
        ...config.params,
        _t: Date.now()
      };
    }
    
    // 显示 Loading
    showLoading();
    
    return config;
  },
  error => {
    hideLoading();
    return Promise.reject(error);
  }
);

// 响应拦截器 ⭐️已更新
request.interceptors.response.use(
  response => {
    hideLoading();
    
    // 统一处理响应数据（新增 timestamp 和 request_id）
    const { code, message, data, timestamp, request_id } = response.data;
    
    // 记录请求ID便于追踪（开发环境）
    if (request_id && process.env.NODE_ENV === 'development') {
      console.debug('Request ID:', request_id, 'Time:', new Date(timestamp * 1000).toISOString());
    }
    
    if (code === 200 || code === 201) {
      return data;
    } else {
      // 业务错误
      showError(message);
      return Promise.reject(new Error(message));
    }
  },
  async error => {
    hideLoading();
    
    if (!error.response) {
      // 网络错误
      showError('网络连接失败，请检查网络');
      return Promise.reject(error);
    }
    
    const { status } = error.response;
    const { request_id, error: errorDetail } = error.response.data || {};
    
    // 记录错误追踪ID
    if (request_id) {
      console.error('Error Request ID:', request_id, 'Detail:', errorDetail);
    }
    
    switch (status) {
      case 401:
        // Token 过期或无效
        try {
          // 尝试刷新 Token
          await refreshToken();
          // 重试原请求
          return request(error.config);
        } catch (refreshError) {
          // 刷新失败，跳转登录页
          showError('登录已过期，请重新登录');
          setTimeout(() => {
            window.location.href = '/login';
          }, 1500);
        }
        break;
        
      case 403:
        showError('没有权限访问该资源');
        break;
        
      case 404:
        showError('请求的资源不存在');
        break;
        
      case 500:
        showError('服务器错误，请稍后重试');
        break;
        
      default:
        showError(error.response.data?.message || '请求失败');
    }
    
    return Promise.reject(error);
  }
);

// Loading 状态管理
let loadingCount = 0;
function showLoading() {
  loadingCount++;
  // 显示 Loading 组件
  // 例如：ElLoading.service()
}

function hideLoading() {
  loadingCount--;
  if (loadingCount <= 0) {
    loadingCount = 0;
    // 隐藏 Loading 组件
  }
}

function showError(message) {
  // 显示错误提示
  // 例如：ElMessage.error(message)
  console.error(message);
}

export default request;
```

### 使用封装后的请求

```javascript
// api/user.js
import request from '../utils/request';

// 获取用户信息
export function getUserProfile() {
  return request({
    url: '/users/profile',
    method: 'get'
  });
}

// 更新用户信息
export function updateUserProfile(data) {
  return request({
    url: '/users/profile',
    method: 'put',
    data
  });
}
```

---

## 核心功能集成

### 用户系统集成

#### 注册流程

```javascript
// components/Register.vue
<script setup>
import { ref } from 'vue';
import { register } from '@/api/auth';
import { useRouter } from 'vue-router';

const router = useRouter();
const form = ref({
  username: '',
  email: '',
  password: '',
  confirmPassword: ''
});

const handleRegister = async () => {
  // 表单验证
  if (form.value.password !== form.value.confirmPassword) {
    alert('两次密码输入不一致');
    return;
  }
  
  try {
    const result = await register({
      username: form.value.username,
      email: form.value.email,
      password: form.value.password
    });
    
    alert('注册成功！');
    router.push('/login');
  } catch (error) {
    console.error('注册失败:', error);
  }
};
</script>
```

#### 登录流程

```javascript
// components/Login.vue
<script setup>
import { ref } from 'vue';
import { login } from '@/api/auth';
import { useRouter } from 'vue-router';
import { useUserStore } from '@/stores/user';

const router = useRouter();
const userStore = useUserStore();

const form = ref({
  username: '',
  password: ''
});

const handleLogin = async () => {
  try {
    const result = await login(
      form.value.username,
      form.value.password
    );
    
    // 更新用户状态
    userStore.setUser(result.data);
    
    // 跳转到首页
    router.push('/');
  } catch (error) {
    console.error('登录失败:', error);
  }
};
</script>
```

#### 个人信息管理

```javascript
// api/user.js
export function getUserProfile() {
  return request.get('/users/profile');
}

export function updateUserProfile(data) {
  return request.put('/users/profile', data);
}

export function changePassword(oldPassword, newPassword) {
  return request.put('/users/password', {
    oldPassword,
    newPassword
  });
}
```

```javascript
// pages/Profile.vue
<script setup>
import { ref, onMounted } from 'vue';
import { getUserProfile, updateUserProfile } from '@/api/user';

const profile = ref({});
const loading = ref(false);

onMounted(async () => {
  loading.value = true;
  try {
    profile.value = await getUserProfile();
  } catch (error) {
    console.error('获取用户信息失败:', error);
  } finally {
    loading.value = false;
  }
});

const handleUpdate = async () => {
  try {
    await updateUserProfile({
      nickname: profile.value.nickname,
      bio: profile.value.bio,
      avatar: profile.value.avatar
    });
    
    alert('更新成功！');
  } catch (error) {
    console.error('更新失败:', error);
  }
};
</script>
```

### 书城系统集成

#### 首页数据展示

```javascript
// api/bookstore.js
export function getHomepageData() {
  return request.get('/bookstore/homepage');
}

export function getBookList(params) {
  return request.get('/bookstore/books', { params });
}

export function getBookDetail(bookId) {
  return request.get(`/bookstore/books/${bookId}`);
}

export function searchBooks(keyword, params) {
  return request.get('/bookstore/books/search', {
    params: { keyword, ...params }
  });
}
```

```javascript
// pages/Home.vue
<script setup>
import { ref, onMounted } from 'vue';
import { getHomepageData } from '@/api/bookstore';

const homepageData = ref({
  banners: [],
  recommendedBooks: [],
  featuredBooks: [],
  categories: []
});

onMounted(async () => {
  try {
    homepageData.value = await getHomepageData();
  } catch (error) {
    console.error('获取首页数据失败:', error);
  }
});
</script>

<template>
  <div class="homepage">
    <!-- Banner 轮播 -->
    <div class="banners">
      <div v-for="banner in homepageData.banners" :key="banner.id">
        <img :src="banner.imageUrl" :alt="banner.title" />
      </div>
    </div>
    
    <!-- 推荐书籍 -->
    <div class="recommended-books">
      <h2>推荐阅读</h2>
      <div class="book-list">
        <div v-for="book in homepageData.recommendedBooks" :key="book.id" class="book-item">
          <img :src="book.coverUrl" :alt="book.title" />
          <h3>{{ book.title }}</h3>
          <p>{{ book.author }}</p>
        </div>
      </div>
    </div>
  </div>
</template>
```

#### 书籍详情页

```javascript
// pages/BookDetail.vue
<script setup>
import { ref, onMounted } from 'vue';
import { useRoute } from 'vue-router';
import { getBookDetail } from '@/api/bookstore';

const route = useRoute();
const book = ref(null);
const loading = ref(false);

onMounted(async () => {
  loading.value = true;
  try {
    const bookId = route.params.id;
    book.value = await getBookDetail(bookId);
  } catch (error) {
    console.error('获取书籍详情失败:', error);
  } finally {
    loading.value = false;
  }
});
</script>

<template>
  <div v-if="book" class="book-detail">
    <img :src="book.coverUrl" :alt="book.title" class="cover" />
    <h1>{{ book.title }}</h1>
    <p class="author">作者：{{ book.author }}</p>
    <p class="description">{{ book.description }}</p>
    <div class="stats">
      <span>阅读量：{{ book.viewCount }}</span>
      <span>收藏：{{ book.likeCount }}</span>
      <span>评分：{{ book.rating }}</span>
    </div>
    <button @click="startReading">开始阅读</button>
  </div>
</template>
```

### 阅读器集成

#### 章节加载

```javascript
// api/reader.js
export function getChapterContent(chapterID) {
  return request.get(`/reader/chapters/${chapterID}/content`);
}

export function getBookChapters(bookID, page = 1, size = 20) {
  return request.get('/reader/chapters', {
    params: { bookId: bookID, page, size }
  });
}
```

```javascript
// pages/Reader.vue
<script setup>
import { ref, onMounted, watch } from 'vue';
import { useRoute } from 'vue-router';
import { getChapterContent } from '@/api/reader';

const route = useRoute();
const content = ref('');
const loading = ref(false);

const loadChapter = async (chapterId) => {
  loading.value = true;
  try {
    const result = await getChapterContent(chapterId);
    content.value = result.content;
  } catch (error) {
    console.error('加载章节失败:', error);
  } finally {
    loading.value = false;
  }
};

onMounted(() => {
  const chapterId = route.params.chapterId;
  loadChapter(chapterId);
});

watch(() => route.params.chapterId, (newId) => {
  if (newId) {
    loadChapter(newId);
  }
});
</script>
```

#### 阅读进度保存

```javascript
// api/reader.js
export function saveReadingProgress(bookId, chapterId, progress) {
  return request.post('/reader/progress', {
    bookId,
    chapterId,
    progress
  });
}

export function getReadingProgress(bookId) {
  return request.get(`/reader/progress/${bookId}`);
}
```

#### 阅读设置

```javascript
// api/reader.js
export function getReadingSettings() {
  return request.get('/reader/settings');
}

export function saveReadingSettings(settings) {
  return request.post('/reader/settings', settings);
}
```

```javascript
// components/ReaderSettings.vue
<script setup>
import { ref, onMounted } from 'vue';
import { getReadingSettings, saveReadingSettings } from '@/api/reader';

const settings = ref({
  fontSize: 16,
  fontFamily: '宋体',
  lineHeight: 1.5,
  backgroundColor: '#FFFFFF',
  textColor: '#000000',
  pageMode: 'scroll'
});

onMounted(async () => {
  try {
    const savedSettings = await getReadingSettings();
    if (savedSettings) {
      settings.value = savedSettings;
    }
  } catch (error) {
    console.error('获取阅读设置失败:', error);
  }
});

const handleSave = async () => {
  try {
    await saveReadingSettings(settings.value);
    alert('保存成功！');
  } catch (error) {
    console.error('保存失败:', error);
  }
};
</script>
```

### 推荐系统集成

#### 个性化推荐

```javascript
// api/recommendation.js
export function getPersonalizedRecommendations(limit = 10) {
  return request.get('/recommendation/personalized', {
    params: { limit }
  });
}

export function getSimilarItems(itemId, limit = 10) {
  return request.get('/recommendation/similar', {
    params: { itemId, limit }
  });
}

export function recordBehavior(behaviorData) {
  return request.post('/recommendation/behavior', behaviorData);
}
```

#### 行为追踪

```javascript
// utils/tracking.js
import { recordBehavior } from '@/api/recommendation';

export function trackView(itemId) {
  recordBehavior({
    itemId,
    behaviorType: 'view',
    value: 1
  });
}

export function trackRead(itemId, chapterId, readTime) {
  recordBehavior({
    itemId,
    chapterID: chapterId,
    behaviorType: 'read',
    value: readTime
  });
}

export function trackLike(itemId) {
  recordBehavior({
    itemId,
    behaviorType: 'like',
    value: 1
  });
}
```

---

## 最佳实践

### 1. 错误处理

#### 网络错误处理

```javascript
// utils/errorHandler.js
export function handleNetworkError(error) {
  if (!navigator.onLine) {
    return '网络连接已断开，请检查网络设置';
  }
  
  if (error.code === 'ECONNABORTED') {
    return '请求超时，请稍后重试';
  }
  
  return '网络错误，请检查网络连接';
}
```

#### 业务错误处理

```javascript
export function handleBusinessError(code, message) {
  const errorMap = {
    40001: '登录已过期，请重新登录',
    40002: '用户名或密码错误',
    40003: '用户已被禁用',
    40301: '没有权限访问该资源',
    40401: '请求的资源不存在',
    50001: '服务器内部错误'
  };
  
  return errorMap[code] || message || '操作失败';
}
```

#### 用户友好的错误提示

```javascript
// utils/message.js
import { ElMessage } from 'element-plus';

export function showSuccessMessage(message) {
  ElMessage.success(message);
}

export function showErrorMessage(error) {
  let message;
  
  if (typeof error === 'string') {
    message = error;
  } else if (error.response) {
    message = error.response.data?.message || '操作失败';
  } else if (error.request) {
    message = '网络错误，请检查网络连接';
  } else {
    message = error.message || '未知错误';
  }
  
  ElMessage.error(message);
}
```

### 2. 性能优化

#### 请求缓存

```javascript
// utils/cache.js
const cache = new Map();
const CACHE_DURATION = 5 * 60 * 1000; // 5分钟

export function getCachedData(key) {
  const cached = cache.get(key);
  
  if (!cached) return null;
  
  if (Date.now() - cached.timestamp > CACHE_DURATION) {
    cache.delete(key);
    return null;
  }
  
  return cached.data;
}

export function setCachedData(key, data) {
  cache.set(key, {
    data,
    timestamp: Date.now()
  });
}
```

```javascript
// api/bookstore.js
import { getCachedData, setCachedData } from '@/utils/cache';

export async function getBookDetail(bookId) {
  const cacheKey = `book_${bookId}`;
  
  // 尝试从缓存获取
  const cached = getCachedData(cacheKey);
  if (cached) {
    return cached;
  }
  
  // 请求新数据
  const data = await request.get(`/bookstore/books/${bookId}`);
  
  // 存入缓存
  setCachedData(cacheKey, data);
  
  return data;
}
```

#### 防抖节流

```javascript
// utils/debounce.js
export function debounce(func, wait) {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

export function throttle(func, wait) {
  let timeout = null;
  let previous = 0;
  
  return function executedFunction(...args) {
    const now = Date.now();
    const remaining = wait - (now - previous);
    
    if (remaining <= 0 || remaining > wait) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
      previous = now;
      func(...args);
    } else if (!timeout) {
      timeout = setTimeout(() => {
        previous = Date.now();
        timeout = null;
        func(...args);
      }, remaining);
    }
  };
}
```

```javascript
// 使用防抖的搜索
<script setup>
import { ref } from 'vue';
import { debounce } from '@/utils/debounce';
import { searchBooks } from '@/api/bookstore';

const searchKeyword = ref('');
const searchResults = ref([]);

const handleSearch = debounce(async (keyword) => {
  if (!keyword) {
    searchResults.value = [];
    return;
  }
  
  try {
    const results = await searchBooks(keyword);
    searchResults.value = results;
  } catch (error) {
    console.error('搜索失败:', error);
  }
}, 500);
</script>
```

#### 分页加载

```javascript
// composables/usePagination.js
import { ref, computed } from 'vue';

export function usePagination(fetchFunction) {
  const list = ref([]);
  const page = ref(1);
  const pageSize = ref(20);
  const total = ref(0);
  const loading = ref(false);
  
  const hasMore = computed(() => {
    return list.value.length < total.value;
  });
  
  const loadMore = async () => {
    if (loading.value || !hasMore.value) return;
    
    loading.value = true;
    try {
      const result = await fetchFunction(page.value, pageSize.value);
      list.value.push(...result.data);
      total.value = result.total;
      page.value++;
    } catch (error) {
      console.error('加载失败:', error);
    } finally {
      loading.value = false;
    }
  };
  
  return {
    list,
    loading,
    hasMore,
    loadMore
  };
}
```

### 3. 安全性

#### Token 安全存储

```javascript
// utils/storage.js
// 使用加密存储敏感信息
import CryptoJS from 'crypto-js';

const SECRET_KEY = 'your-secret-key';

export function setSecureItem(key, value) {
  const encrypted = CryptoJS.AES.encrypt(value, SECRET_KEY).toString();
  localStorage.setItem(key, encrypted);
}

export function getSecureItem(key) {
  const encrypted = localStorage.getItem(key);
  if (!encrypted) return null;
  
  try {
    const decrypted = CryptoJS.AES.decrypt(encrypted, SECRET_KEY);
    return decrypted.toString(CryptoJS.enc.Utf8);
  } catch (error) {
    return null;
  }
}
```

#### XSS 防护

```javascript
// utils/xss.js
export function escapeHtml(text) {
  const map = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#039;'
  };
  
  return text.replace(/[&<>"']/g, m => map[m]);
}
```

#### CSRF 防护

```javascript
// request.js 中添加 CSRF Token
request.interceptors.request.use(config => {
  const csrfToken = document.querySelector('meta[name="csrf-token"]')?.content;
  if (csrfToken) {
    config.headers['X-CSRF-Token'] = csrfToken;
  }
  return config;
});
```

---

## 常见问题

### Q1: Token 过期后如何处理？

**A**: 在响应拦截器中自动刷新 Token：

```javascript
// 401错误时自动刷新Token
if (error.response.status === 401) {
  try {
    await refreshToken();
    return request(error.config); // 重试原请求
  } catch (refreshError) {
    // 刷新失败，跳转登录页
    window.location.href = '/login';
  }
}
```

### Q2: 如何处理跨域问题？

**A**: 开发环境使用代理：

```javascript
// vite.config.js
export default {
  server: {
    proxy: {
      '/api': {
        target: 'http://localhost:8080',
        changeOrigin: true
      }
    }
  }
}
```

生产环境需要后端配置CORS。

### Q3: 如何实现文件上传？

**A**: 使用 FormData：

```javascript
export function uploadFile(file) {
  const formData = new FormData();
  formData.append('file', file);
  
  return request.post('/shared/storage/upload', formData, {
    headers: {
      'Content-Type': 'multipart/form-data'
    },
    onUploadProgress: (progressEvent) => {
      const progress = Math.round((progressEvent.loaded * 100) / progressEvent.total);
      console.log(`上传进度: ${progress}%`);
    }
  });
}
```

### Q4: 如何实现请求取消？

**A**: 使用 AbortController：

```javascript
const controller = new AbortController();

export function searchBooks(keyword) {
  return request.get('/bookstore/books/search', {
    params: { keyword },
    signal: controller.signal
  });
}

// 取消请求
controller.abort();
```

### Q5: 如何处理并发请求？

**A**: 使用 Promise.all：

```javascript
async function loadPageData() {
  try {
    const [user, books, settings] = await Promise.all([
      getUserProfile(),
      getRecommendedBooks(),
      getReadingSettings()
    ]);
    
    return { user, books, settings };
  } catch (error) {
    console.error('加载数据失败:', error);
  }
}
```

---

## 完整示例项目

### Vue 3 + Vite 项目结构

```
src/
├── api/                  # API 接口
│   ├── auth.js
│   ├── user.js
│   ├── bookstore.js
│   ├── reader.js
│   └── recommendation.js
├── components/           # 组件
│   ├── Header.vue
│   ├── BookCard.vue
│   └── ReaderSettings.vue
├── composables/          # 组合式函数
│   ├── useAuth.js
│   ├── usePagination.js
│   └── useReader.js
├── pages/                # 页面
│   ├── Home.vue
│   ├── Login.vue
│   ├── BookDetail.vue
│   └── Reader.vue
├── stores/               # 状态管理
│   ├── user.js
│   └── reader.js
├── utils/                # 工具函数
│   ├── request.js
│   ├── storage.js
│   └── debounce.js
├── config/               # 配置
│   └── api.js
├── App.vue
└── main.js
```

### 示例仓库

GitHub: [qingyu-frontend-example](https://github.com/qingyu/qingyu-frontend-example)

---

## 相关文档

- [API 快速参考](./API快速参考.md)
- [用户系统 API 参考](./用户系统API参考.md)
- [书城系统 API 参考](./书城API参考.md)
- [阅读器 API 参考](./阅读器API参考.md)

---

**维护者**: 青羽后端团队  
**联系方式**: backend@qingyu.com

