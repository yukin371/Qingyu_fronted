# 统一响应处理指南

> **文件位置**: `api/v1/shared/response.go`
> **更新日期**: 2025-10-08
> **状态**: ✅ 已实现

---

## 📋 概述

为了确保整个项目的API响应格式统一，我们在 `api/v1/shared`包中定义了一套标准的响应处理函数。所有API层的代码都应该使用这些函数来返回响应，而不是直接调用 `c.JSON()`。

---

## 🎯 核心响应函数

### 1. Success - 成功响应

用于所有API成功情况。

```go
func Success(c *gin.Context, statusCode int, message string, data interface{})
```

**使用示例**：

```go
// 返回单个对象
shared.Success(c, http.StatusOK, "获取成功", user)

// 返回列表
shared.Success(c, http.StatusOK, "获取成功", users)

// 返回创建结果
shared.Success(c, http.StatusCreated, "创建成功", newBook)

// 返回空数据
shared.Success(c, http.StatusOK, "保存成功", nil)

// 返回复杂数据
shared.Success(c, http.StatusOK, "获取成功", gin.H{
    "chapters": chapters,
    "total":    total,
    "page":     page,
})
```

**响应格式**：

```json
{
  "code": 200,
  "message": "获取成功",
  "data": { ... },
  "timestamp": 1696789200
}
```

---

### 2. Error - 错误响应

用于所有API错误情况。

```go
func Error(c *gin.Context, statusCode int, message string, errorDetail string)
```

**使用示例**：

```go
// 资源不存在
shared.Error(c, http.StatusNotFound, "章节不存在", err.Error())

// 内部错误
shared.Error(c, http.StatusInternalServerError, "获取阅读进度失败", err.Error())

// 业务逻辑错误
shared.Error(c, http.StatusConflict, "用户名已存在", "该用户名已被注册")

// 参数错误
shared.Error(c, http.StatusBadRequest, "参数错误", "书籍ID不能为空")

// 权限不足
shared.Error(c, http.StatusForbidden, "获取章节内容失败", err.Error())
```

**响应格式**：

```json
{
  "code": 404,
  "message": "章节不存在",
  "error": "chapter not found in database",
  "timestamp": 1696789200
}
```

---

### 3. ValidationError - 参数验证错误

专门用于处理参数验证失败的情况。

```go
func ValidationError(c *gin.Context, err error)
```

**使用示例**：

```go
var req SaveProgressRequest
if err := c.ShouldBindJSON(&req); err != nil {
    shared.ValidationError(c, err)
    return
}
```

**响应格式**：

```json
{
  "code": 400,
  "message": "参数验证失败",
  "error": "Field validation for 'BookID' failed on the 'required' tag",
  "timestamp": 1696789200
}
```

---

## 🚀 便捷响应函数

为常见的HTTP状态码提供了便捷函数：

### 4. Unauthorized - 未授权 (401)

```go
func Unauthorized(c *gin.Context, message string)
```

**使用示例**：

```go
userID, exists := c.Get("userId")
if !exists {
    shared.Unauthorized(c, "请先登录")
    return
}
```

**响应格式**：

```json
{
  "code": 401,
  "message": "请先登录",
  "error": "请先登录或提供有效的访问凭证",
  "timestamp": 1696789200
}
```

---

### 5. Forbidden - 禁止访问 (403)

```go
func Forbidden(c *gin.Context, message string)
```

**使用示例**：

```go
if !hasPermission {
    shared.Forbidden(c, "您没有权限访问此章节")
    return
}
```

---

### 6. NotFound - 资源不存在 (404)

```go
func NotFound(c *gin.Context, message string)
```

**使用示例**：

```go
chapter, err := api.readerService.GetChapterByID(c.Request.Context(), chapterID)
if err != nil {
    shared.NotFound(c, "章节不存在")
    return
}
```

---

### 7. BadRequest - 错误请求 (400)

```go
func BadRequest(c *gin.Context, message string, errorDetail string)
```

**使用示例**：

```go
bookID := c.Query("bookId")
if bookID == "" {
    shared.BadRequest(c, "参数错误", "书籍ID不能为空")
    return
}
```

---

### 8. InternalError - 内部服务器错误 (500)

```go
func InternalError(c *gin.Context, message string, err error)
```

**使用示例**：

```go
progress, err := api.readerService.GetReadingProgress(ctx, userID, bookID)
if err != nil {
    shared.InternalError(c, "获取阅读进度失败", err)
    return
}
```

---

## 📦 分页响应

### 9. Paginated - 分页响应

```go
func Paginated(c *gin.Context, data interface{}, total int64, page, pageSize int, message string)
```

**使用示例**：

```go
chapters, total, err := api.readerService.GetBookChaptersWithPagination(ctx, bookID, page, size)
if err != nil {
    shared.Error(c, http.StatusInternalServerError, "获取章节列表失败", err.Error())
    return
}

shared.Paginated(c, chapters, total, page, size, "获取成功")
```

**响应格式**：

```json
{
  "code": 200,
  "message": "获取成功",
  "data": [...],
  "timestamp": 1696789200,
  "pagination": {
    "total": 100,
    "page": 1,
    "page_size": 20,
    "total_pages": 5,
    "has_next": true,
    "has_previous": false
  }
}
```

---

## 🔑 带RequestID的响应

用于需要追踪请求的场景：

### 10. SuccessWithRequestID

```go
func SuccessWithRequestID(c *gin.Context, statusCode int, message string, data interface{}, requestID string)
```

### 11. ErrorWithRequestID

```go
func ErrorWithRequestID(c *gin.Context, statusCode int, message string, errorDetail string, requestID string)
```

**使用示例**：

```go
requestID := c.GetString("request_id") // 从中间件获取
shared.SuccessWithRequestID(c, http.StatusOK, "获取成功", data, requestID)
```

---

## 📚 实际应用示例

### 阅读器API完整示例

```go
package reader

import (
    "net/http"
    "github.com/gin-gonic/gin"
    "Qingyu_backend/api/v1/shared"
    "Qingyu_backend/service/reading"
)

type SettingAPI struct {
    readerService *reading.ReaderService
}

// GetReadingSettings 获取阅读设置
func (api *SettingAPI) GetReadingSettings(c *gin.Context) {
    // 1. 验证用户认证
    userID, exists := c.Get("userId")
    if !exists {
        shared.Unauthorized(c, "请先登录")
        return
    }

    // 2. 调用Service层
    settings, err := api.readerService.GetReadingSettings(c.Request.Context(), userID.(string))
    if err != nil {
        shared.InternalError(c, "获取阅读设置失败", err)
        return
    }

    // 3. 返回成功响应
    shared.Success(c, http.StatusOK, "获取成功", settings)
}

// SaveReadingSettings 保存阅读设置
func (api *SettingAPI) SaveReadingSettings(c *gin.Context) {
    // 1. 验证用户认证
    userID, exists := c.Get("userId")
    if !exists {
        shared.Unauthorized(c, "请先登录")
        return
    }

    // 2. 参数绑定和验证
    var settings reader.ReadingSettings
    if err := c.ShouldBindJSON(&settings); err != nil {
        shared.ValidationError(c, err)
        return
    }

    // 3. 设置用户ID
    settings.UserID = userID.(string)

    // 4. 调用Service层
    err := api.readerService.SaveReadingSettings(c.Request.Context(), &settings)
    if err != nil {
        shared.InternalError(c, "保存阅读设置失败", err)
        return
    }

    // 5. 返回成功响应
    shared.Success(c, http.StatusOK, "保存成功", nil)
}

// GetBookChapters 获取书籍章节列表（分页）
func (api *ChaptersAPI) GetBookChapters(c *gin.Context) {
    // 1. 参数验证
    bookID := c.Query("bookId")
    if bookID == "" {
        shared.BadRequest(c, "参数错误", "书籍ID不能为空")
        return
    }

    page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
    size, _ := strconv.Atoi(c.DefaultQuery("size", "20"))

    // 2. 调用Service层
    chapters, total, err := api.readerService.GetBookChaptersWithPagination(
        c.Request.Context(), bookID, page, size)
    if err != nil {
        shared.InternalError(c, "获取章节列表失败", err)
        return
    }

    // 3. 返回分页响应
    shared.Paginated(c, chapters, total, page, size, "获取成功")
}
```

---

## ✅ 最佳实践

### 1. 始终使用统一响应函数

❌ **错误做法**：

```go
c.JSON(http.StatusOK, gin.H{
    "code": 200,
    "message": "success",
    "data": user,
})
```

✅ **正确做法**：

```go
shared.Success(c, http.StatusOK, "获取成功", user)
```

---

### 2. 选择合适的响应函数

根据具体场景选择最合适的函数：

```go
// 通用错误 - 使用Error
shared.Error(c, http.StatusInternalServerError, "操作失败", err.Error())

// 未授权 - 使用Unauthorized
shared.Unauthorized(c, "请先登录")

// 资源不存在 - 使用NotFound
shared.NotFound(c, "用户不存在")

// 参数错误 - 使用BadRequest
shared.BadRequest(c, "参数错误", "用户ID不能为空")

// 参数验证 - 使用ValidationError
shared.ValidationError(c, err)
```

---

### 3. 提供有意义的错误信息

❌ **错误做法**：

```go
shared.Error(c, http.StatusInternalServerError, "错误", "失败")
```

✅ **正确做法**：

```go
shared.Error(c, http.StatusInternalServerError, "获取阅读进度失败", err.Error())
```

---

### 4. 使用合适的HTTP状态码

| 场景       | 状态码 | 响应函数                                        |
| ---------- | ------ | ----------------------------------------------- |
| 成功获取   | 200    | `Success(c, http.StatusOK, ...)`              |
| 成功创建   | 201    | `Success(c, http.StatusCreated, ...)`         |
| 参数错误   | 400    | `BadRequest(...)` 或 `ValidationError(...)` |
| 未授权     | 401    | `Unauthorized(...)`                           |
| 禁止访问   | 403    | `Forbidden(...)`                              |
| 资源不存在 | 404    | `NotFound(...)`                               |
| 内部错误   | 500    | `InternalError(...)`                          |

---

### 5. 分页响应统一格式

所有分页API都应该使用 `Paginated`函数：

```go
shared.Paginated(c, items, total, page, pageSize, "获取成功")
```

这样可以确保前端获得统一的分页信息格式。

---

## 📊 响应格式规范

### 成功响应结构

```typescript
interface SuccessResponse {
  code: number;           // HTTP状态码
  message: string;        // 成功消息
  data?: any;            // 数据内容（可选）
  timestamp: number;      // 响应时间戳
  request_id?: string;   // 请求ID（可选）
}
```

### 错误响应结构

```typescript
interface ErrorResponse {
  code: number;           // HTTP状态码
  message: string;        // 错误消息
  error?: string;        // 详细错误信息（可选）
  timestamp: number;      // 响应时间戳
  request_id?: string;   // 请求ID（可选）
}
```

### 分页响应结构

```typescript
interface PaginatedResponse {
  code: number;
  message: string;
  data?: any[];
  timestamp: number;
  request_id?: string;
  pagination: {
    total: number;        // 总记录数
    page: number;         // 当前页码
    page_size: number;    // 每页大小
    total_pages: number;  // 总页数
    has_next: boolean;    // 是否有下一页
    has_previous: boolean; // 是否有上一页
  };
}
```

---

## 🔍 调试技巧

### 1. 使用RequestID追踪请求

```go
// 在中间件中设置RequestID
func RequestIDMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        requestID := uuid.New().String()
        c.Set("request_id", requestID)
        c.Next()
    }
}

// 在API中使用
requestID := c.GetString("request_id")
shared.SuccessWithRequestID(c, http.StatusOK, "获取成功", data, requestID)
```

### 2. 日志记录

```go
log.WithFields(logrus.Fields{
    "request_id": requestID,
    "user_id":    userID,
    "error":      err.Error(),
}).Error("获取阅读进度失败")

shared.ErrorWithRequestID(c, http.StatusInternalServerError, 
    "获取阅读进度失败", err.Error(), requestID)
```

---

## 📝 迁移指南

如果你有旧代码使用了直接的 `c.JSON()`调用，按照以下步骤迁移：

### 步骤1: 识别响应类型

```go
// 旧代码
c.JSON(http.StatusOK, gin.H{"code": 200, "data": user})
```

### 步骤2: 选择合适的响应函数

```go
// 新代码
shared.Success(c, http.StatusOK, "获取成功", user)
```

### 步骤3: 统一错误处理

```go
// 旧代码
if err != nil {
    c.JSON(http.StatusInternalServerError, gin.H{
        "code": 500,
        "error": err.Error(),
    })
    return
}

// 新代码
if err != nil {
    shared.InternalError(c, "操作失败", err)
    return
}
```

---

## 🎯 检查清单

在提交代码前，请确保：

- [ ] 所有API都使用了 `shared`包的响应函数
- [ ] 没有直接使用 `c.JSON()`
- [ ] 错误消息清晰明确
- [ ] 使用了正确的HTTP状态码
- [ ] 分页API使用了 `Paginated`函数
- [ ] 响应格式符合规范

---

## 📚 相关文档

- [API设计规范](../API设计规范.md)
- [错误处理规范](../../architecture/错误处理规范.md)
- [阅读器API文档](../阅读器API文档.md)

---

## ✨ 总结

统一的响应处理函数带来的好处：

1. **一致性** - 所有API返回统一格式的响应
2. **可维护性** - 集中管理响应格式，便于修改
3. **可读性** - 代码更简洁清晰
4. **可扩展性** - 易于添加新功能（如RequestID、日志等）
5. **前端友好** - 统一的数据格式便于前端处理

**请在所有新API中使用这些统一的响应函数！** ✅

---

**最后更新**: 2025-10-08
**版本**: v1.0
